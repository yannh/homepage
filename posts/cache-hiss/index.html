<!doctype html><html><head><meta charset=utf-8><meta name=author content="Yann Hamon"><link rel=stylesheet type=text/css href=/css/style.css><title>Yann Hamon | The curious case of the CDN Cache-HISS</title></head><body><div id=main-container><div id=post><a href=/ id=back>‚Üê Back</a><h1>The curious case of the CDN Cache-HISS<div class=date>August 6, 2023</div></h1><p>A few years ago, I was asked to take a more active role maintaining the CDN configuration of the company I work for. My knowledge of CDNs at the time was <em>pretty basic</em> and could be summarised by the following diagramm:</p><p><img src=/assets/cache-hit-miss.png alt="Cache-Hit or Cache-MISS"></p><p>&ldquo;Sure, I got this&rdquo;. And for a short time, things were good. But soon after, I was asked the following question:</p><p>&ldquo;We are reviewing the performance of a client&rsquo;s requests - several of their requests are quite slow, despite being Cache HITs. What&rsquo;s going on?&rdquo;.</p><p>And I soon realised, who would have guessed - things are never that simple. Cache-HITs? Cache-MISSes? Cache-HIT ratios? Things have gotten complicated, and those terms don&rsquo;t make all that much sense anymore..</p><p>Let me introduce you: the cache HISS. It&rsquo;s the request that is a little bit of a cache-HIT, a little bit of a cache-MISS&mldr; and it comes in different flavours!</p><h1 id=definitions>Definitions</h1><p>But before going further, let&rsquo;s define some important terms. In this blog post, we will be using the following definitions:</p><ul><li>A cache <em>HIT</em> is a request where the response is served using content that was previously cached by the CDN.</li><li>A cache <em>MISS</em> is a request where the response comes from the CDN origin / the &ldquo;backend&rdquo; behind the CDN.</li></ul><p>These are <em>derived</em> from the <a href=https://developer.fastly.com/reference/vcl/variables/miscellaneous/fastly-info-state/>Fastly documentation</a>. I am not aware of an industry-standard definition - consider this my attempt at defining those terms!</p><h1 id=http-304---not-modified>HTTP 304 - Not Modified</h1><p>Imagine you are managing a CDN in front of a file repository. All the files in the repository are quite large, maybe several GBs. Those files do change, but really quite rarely. It is acceptable if new versions of a file are served within one hour of being uploaded, therefore you configure a Time-To-Live (TTL) in your CDN: the CDN should cache the file for not more than one hour after retrieval.</p><p>Assuming each file is requested several times per hour, this would mean that the CDN would need to download each file again every hour, to ensure it has the latest version in cache. In practice, a CDN has multiple caches around the globe (Points-of-Presence or POPs), so it might be worse: each POP might need to refresh every file every hour.</p><p>This could quickly become very expensive and impractical: your file server would be constantly sending many large files that have not changed to the CDN.</p><p>To not overload the server, modern CDNs use <a href=https://en.wikipedia.org/wiki/HTTP_ETag>ETags</a>. If the CDN receives a request for which the cached file&rsquo;s TTL has expired, it will compute a <em>hash</em> of the file in cache that is not valid anymore, and send that hash along with the request. This is akin to saying to your fileserver &ldquo;Can you send me file X? I already have this version in cache, so it has not changed, don&rsquo;t sent me the whole file again&rdquo;.</p><p>If your fileserver supports ETAGs, it will compute the ETAG of the file requested. If the file has not changed and the computed ETAG matches the ETAG sent by the CDN, instead of sending the whole file back, your fileserver will return a HTTP/304 Not Modified response. The CDN would then renew the TTL of the file in cache for another 60 minutes, <em>and serve the file it has in cache</em>.</p><p>What happened?</p><ul><li>The request was served by the CDN, using content that was previously cached</li><li>However, the request went to the fileserver, and potentially required some computation there.</li></ul><p>According to our definition - this is a cache-HIT. Somewhat unintuitively though, the request was sent to the backend server, which had to do some computation&mldr; and is therefore quite different from a request that was immediately served from cache without revalidation.</p><p>Cache-HISS?</p><h1 id=request-collapsing>Request collapsing</h1><p>To improve on the previous architecture, you decide that setting a TTL of 1h on your files is not that great after all. You need to wait up to an hour for the new versions of your files to be served, and the revalidations requests from the CDN are not very efficient - most of your files never change!</p><p>You decide that having a much higher TTL (1 year), and purging files from the CDN when they change would mean fewer revalidation requests to your fileserver, and ensuring the new versions of the files are available much sooner.</p><p>Now - some of the files are requested quite a lot. Especially after a file changes, a lot of people want to download the new version! So let&rsquo;s see what would actually happen.</p><ul><li>You upload a new version of a large file.</li><li>You send a purge request for that file to the CDN.</li><li>You send an email advertising that there is a new version of the file</li><li>Over the next 10 seconds after you sent the email, 100 different persons start downloading the file.</li><li><em>Assuming it takes 10 seconds for the CDN to retrieve the file from the backend server</em>, for 10 seconds following the first request, the file will not be in the CDN&rsquo;s cache yet.</li><li>Since the CDN does not have the file in cache when those 100 requests are received, the CDN makes 100 requests to the backend, which serves the same large file 100 times.</li></ul><p>This is quite impractical - and to reduce the impact on the backend server, modern CDNs will use <a href=https://developer.fastly.com/learning/concepts/edge-state/cache/request-collapsing/>request collapsing</a>. Request collapsing is an optimisation where the CDN will realise, upon receiving one of these 100 requests, that it already is retrieving that file from the backend for an earlier request. It will therefore &ldquo;park&rdquo; the request, waiting for the earlier request to complete. Once the earlier request is completed, the file will be served from cache for all &ldquo;parked&rdquo; requests. We say that those &ldquo;parked&rdquo; requests are &ldquo;collapsed&rdquo; into the earlier request.</p><p>What happened?</p><ul><li>The first request returned content served by the fileserver, and was a cache MISS.</li><li>The other 99 requests served data from the CDN cache, populated by the first requests. They are, technically, cache HITs.</li></ul><p>Unintuitively enough - while the requests that returned cache HITs did not go to the backend server, they were waiting, some for up to 10second, for the first request to complete.</p><p>Cache HISS?</p><h1 id=multi-tiered-architectures>Multi-Tiered architectures</h1><p>In an earlier blog post about the <a href=https://yann.mandragor.org/posts/lambda-execution-model/>execution model of AWS Lambda@edge in Cloudfront</a>, I briefly touched on the concept of multi-tiered CDN architectures. Indeed most CDN nowadays [<a href=https://blog.cloudflare.com/orpheus/>Cloudflare&rsquo;s orpheus</a>, <a href=https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/origin-shield.html>Cloudfront Origin shield</a>, <a href=https://developer.fastly.com/learning/concepts/shielding/>Fastly shielding</a>] enable the configuration of multiple layers of caching, 2, sometimes even 3.</p><p><img src=/assets/cloudfront-tiered-architecture.png alt="Cloudfront&rsquo;s tiered architecture"></p><p>In this example of a three-tier setup with Cloudfront, the &ldquo;edge location&rdquo; will be geographically quite close to the user - but the &ldquo;origin shield&rdquo; will be geographically much closer to the origin file server, and potentially quite far from the user. What this architecture implies - is that a request might be a HIT or a MISS in every of the different caching layers.</p><p>Let&rsquo;s take the following use-case: you have a fileserver located in Virgina (US-East), and use a CDN using a three-tiered architecture such as the one presented above. Your fileserver is in Virginia (us-east), and a user from India requests a 1KB file. Noone in india requested that file in India before, therefore neither the edge location nor the Regional Edge cache has the file in cache. The request therefore goes all around the globe to US-East to the origin shield cache. Someone in the US requested that file earlier, therefore the file is in cache in the origin shield, and the request is therefore a Cache-HIT in the shield.</p><p>What happened?</p><ul><li>The request returned to the user was served by the CDN cache, it is a Cache-HIT</li><li>However, the request had to go all around the planet to reach the origin shield, and was barely faster than a non-cached request.</li></ul><p>Cache-HISS?</p><h1 id=stale-content-stale-on-5xx>Stale content (stale-on-5xx)</h1><p>When a file is cached by a CDN and its TTL expires, or if you purge that file from the CDN, the CDN will often keep the file in cache for a little while and mark it as &ldquo;stale&rdquo;, instead of directly deleting it. This is because <em>in some cases</em>, you might decide that serving content that is slightly out of date is better than the alternative.</p><p>The most common case is when the TTL of a cached file in the CDN expires, and the CDN tries to fetch a new version from your backend server. What if there is an error fetching the new version, because your fileserver is currently overloaded or down? Would it be better to serve a 5xx HTTP error - or a slightly outdated file?</p><p>This behavious is known as <em>stale-on-error</em> and is available with <a href=https://aws.amazon.com/about-aws/whats-new/2023/05/amazon-cloudfront-stale-while-revalidate-stale-if-error-cache-control-directives/>most</a> <a href=https://developers.cloudflare.com/cache/concepts/cache-control/#revalidation>CDN</a> <a href=https://docs.fastly.com/en/guides/serving-stale-content#serving-stale-content-on-errors>providers</a>. Depending on your business requirements, this might be a good option to turn on.</p><p>Let&rsquo;s take the following example:</p><ul><li>A user requests a file</li><li>The CDN has a cached version of that file, but since the TTL of that cached object expired, it forwards the request to the backend server</li><li>The backend server is currently overloaded - the connection times out after several seconds.</li><li>The option &ldquo;stale-on-error&rdquo; is turned on - therefore the CDN serves the stale object from cache.</li></ul><p>What happened?</p><ul><li>The file was served from cache - it is a cache HIT</li><li>The request went to the origin (or tried to). It was very slow to complete since the CDN waited for a timeout to occur before giving up and serving the stale file.</li></ul><p>Cache HISS!</p><h2 id=final-thoughts>Final thoughts</h2><p>The fact that a request is a cache &ldquo;HIT&rdquo; tells us very little about what happened. In some cases, the request might hit a caching layer half way around the planet, wait for another request to complete, hit a timeout or an error, or even hit the origin and require computation there. It tells us nothing about the two things that really matter:</p><ul><li>Was the user experience good - was the file served to the user with low latency?</li><li>Did the request put load on the backend server?</li></ul><p>By extension: cache HISSes might completely skew what you believe the cache-HIT ratio reported by your CDN is telling you. It does not necessarily correlate with a good user experience, not is it necessarily an indication of how many requests reach your origin. There is also no agreed standard on how to measure the cache-HIT ratio - depending on your provider, it might be unclear how cache HISSes are counted.</p><p>So - forget about cache hit ratios! And measure what matters:</p><ul><li>With what latency was the file served (Time To First Byte, Total)? You might measure this either at the edge of your network, in the CDN - or using instrumentation on the client side.</li><li>How many requests, from all requests, reached the origin? Especially if the requests require heavy computation (in the case of a REST or GraphQL API), returning 304s might not save you all this much.</li></ul><a href=https://yann.mandragor.org/posts/lambda-execution-model/ id=prev>&lt; The execution model of AWS Lambda@edge with Cloudfront's two- and three-tiered architecture</a></div></div></body></html>