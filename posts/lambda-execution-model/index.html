<!doctype html><html><head><meta charset=utf-8><meta name=author content="Yann Hamon"><link rel=stylesheet type=text/css href=/css/style.css><title>Yann Hamon | The execution model of AWS Lambda@edge with Cloudfront's two- and three-tiered architecture</title></head><body><div id=main-container><div id=post><a href=/ id=back>‚Üê Back</a><h1>The execution model of AWS Lambda@edge with Cloudfront's two- and three-tiered architecture<div class=date>July 2, 2021</div></h1><p>The <a href=https://aws.amazon.com/about-aws/whats-new/2016/12/introducing-lambda-at-edge-in-preview-run-lambda-function-at-aws-edge-locations-closest-to-your-users/>introduction of Lambda@Edge</a>
in 2016/2017 was probably one of the most significant updates to AWS Cloudfront in the last decade. By enabling
customers to run code directly in Cloudfront&rsquo;s Point-Of-Presences (POPs), AWS was at the forefront of
<a href=https://en.wikipedia.org/wiki/Edge_computing>edge computing</a>, leveraging
<a href=https://aws.amazon.com/blogs/networking-and-content-delivery/category/networking-content-delivery/lambdaedge/>countless</a>
use-cases, from simple header manipulation, to custom authentication workflows.</p><p>Lambda@Edge relies on a <a href=https://docs.aws.amazon.com/lambda/latest/dg/lambda-edge.html>simple execution model</a> that
defines four different places to manipulate CloudFront request or response objects:</p><p><img src=/assets/lambda-edge-simple.png alt="Lambda@Edge execution model"></p><p>The four different lambda types are:</p><table><thead><tr><th>Lambda type</th><th>Location</th><th>Executes</th><th>Manipulates</th></tr></thead><tbody><tr><td>viewer-request</td><td>Before cache</td><td>Every request</td><td>Request</td></tr><tr><td>origin-request</td><td>After cache</td><td>On cache misses</td><td>Request</td></tr><tr><td>origin-response</td><td>After cache</td><td>On cache misses</td><td>Response</td></tr><tr><td>viewer-response</td><td>Before cache</td><td>Every request</td><td>Response</td></tr></tbody></table><p>A few immediate observations:</p><ul><li>Origin-request and origin-response lambdas are not run on cache hits, and therefore do not impact the performance
of cache-hits.</li><li>Viewer-request and viewer-response lambdas are run on every request. This can get quite expensive on Cloudfront
distribution with significant traffic.</li></ul><h3 id=a-two-tiered-caching-architecture>A two-tiered caching architecture</h3><p>This execution model assumes a single Cloudfront cache between the end-user and the origin. According to this model,
if the POP (edge cache) hit by the end-user is Marseille, France (MRS50), all four lambdas would be run there,
and that POP would send all cache misses to the origin.</p><p>In reality however, Cloudfront does not forward cache misses from the edge cache to the origin, but will send the
request to a <a href=https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/HowCloudFrontWorks.html#CloudFrontRegionaledgecaches>regional edge cache</a>
first. This is a secondary layer of cache, in the same geographic area as the edge cache, that has much more storage,
and is more likely to have the file cached: it&rsquo;s a &ldquo;Super-POP&rdquo; of sorts! Cloudfront provides a map with the
<a href=https://aws.amazon.com/cloudfront/features/>regional POP locations</a>.</p><p>This is how this two-tier caching system would work without lambdas:</p><p><img src=/assets/lambda-edge-2-tier-no-lambda.png alt="Cloudfront 2-tier architecture"></p><p>So, where are lambdas executed, after all? <strong>Lambdas@Edge are always executed in the regional edge cache</strong>. Edge
caches can not run lambdas@edge functions - only <a href=https://aws.amazon.com/blogs/aws/introducing-cloudfront-functions-run-your-code-at-the-edge-with-low-latency-at-any-scale/>Cloudfront functions</a>
which we will discuss later.</p><p>This gives us the following:</p><p><img src=/assets/lambda-edge-2-tier-with-lambda.png alt="Cloudfront 2-tier architecture"></p><p>One of the non-obvious implications is that, because lambda@edge functions can only run in a regional edge cache, and
because &ldquo;viewer requests&rdquo; lambdas need to run on every request and <em>before</em> the cache, <strong>attaching a viewer-request
lambda to a distribution disables caching in the edge cache</strong>.</p><p>Edge caches might still be used to terminate the TCP connection closer to the user, but won&rsquo;t be able to cache files
anymore, increasing cache-hits latency.</p><h3 id=origin-shield-or-cloudfronts-new-three-tiered-caching-architecture>Origin shield, or Cloudfront&rsquo;s new three-tiered caching architecture</h3><p>At the end of 2020, Cloudfront announced <a href=https://aws.amazon.com/about-aws/whats-new/2020/10/announcing-amazon-cloudfront-origin-shield/>Cloudfront Origin Shield</a>,
an additional caching layer, close to the origin, to help further reduce the number of requests sent to the origin.</p><p>If there were previously 10 regional caches, for a new file, it would take at least 10 requests to the origin
to have that file cached in all edge regional caches. With an origin shield, since all regional
caches would send the request through that shield, only a single request to the origin would be executed.</p><p>Of course this complicates the Lambda execution model.</p><p><img src=/assets/lambda-edge-3-tier-with-lambda.png alt="Cloudfront 3-tier architecture"></p><p>Indeed, origin-requests need to run <em>after the cache</em>. Adding an origin shield to your Cloudfront distribution
changes where your origin-* lambda are executed: they will now be run at the origin-shield instead of the
regional cache. Depending on your use-case, this might be appropriate - but it is important to node that
origin-requests are now executed close to the origin, and potentially quite far from the user and the edge.</p><h3 id=cloudfront-functions>Cloudfront functions</h3><p>Because of the limitations of lambda@edge, AWS introduced <a href=https://aws.amazon.com/blogs/aws/introducing-cloudfront-functions-run-your-code-at-the-edge-with-low-latency-at-any-scale/>Cloudfront functions</a>.
Cloudfront functions are <em>lightweight</em> lambda@edge functions that are small enough to run in edge caches, allowing
better latency: they run closer to the user, and have a smaller cold-start time. They however come with <a href=https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/edge-functions-restrictions.html>more
constraining restrictions</a>,
especially a maximum of 1ms of execution time.</p><p>Cloudfront functions can be used for viewer-request and viewer-response functions, in lieu of lambda@edge viewer-*
functions, and can be combined with lambda@edge origin-request and origin-response functions.</p><p>This gives us this final execution model, replacing the viewer-request lambda@edge function by a Cloudfront function.</p><p><img src=/assets/lambda-edge-3-tier-with-function.png alt="Cloudfront 3-tier architecture with Cloudfront function"></p><h3 id=closing-thoughts>Closing Thoughts</h3><p>As Cloudfront evolves from a simple architecture to a two- to three-tiered architecture, the lambda@edge execution
model remains unchanged and tries to mask this added complexity, at the risk of having users misunderstand where
their code is actually executed.</p><a href=https://yann.mandragor.org/posts/purge-group-pattern/ id=prev>&lt; Solving the CDN post-purge thundering herd problem: The PurgeGroup pattern</a></div></div></body></html>